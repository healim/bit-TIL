## 180326 p252~



#### 상수 - 객체 생길 때 그림, toString Override 이해

```java
package the.finals;

class TestMember{
	
}
class Finalvariables {
	// 객체의 상수
	public final TestMember VARS = new TestMember();
	// getter
	public TestMember getVAR() {
		return VARS;
	}
	
}
public class FinalvariablesTest {

	public static void main(String[] args) {
		
		Finalvariables fv1 = new Finalvariables();
		System.out.printf("fv1.VARS[0] : %s %n", fv1.VARS);
	
		Finalvariables fv2 = new Finalvariables();
		System.out.printf("fv2.VARS[0] : %s %n", fv2.VARS);
		
		Finalvariables fv3 = new Finalvariables();
		System.out.printf("fv3.VARS[0] : %s %n", fv3.VARS);

	}

}
```

```
fv1.VARS[0] : the.finals.TestMember@28d93b30 
fv2.VARS[0] : the.finals.TestMember@1b6d3586 
fv3.VARS[0] : the.finals.TestMember@4554617c 
```

static 붙인 후 \(객체 상수 됨\)

```java
package the.finals;

class TestMember{
	
}
class Finalvariables {
	// 객체의 상수
	public static final TestMember VARS = new TestMember();
	// getter
	public TestMember getVAR() {
		return VARS;
	}
	
}
public class FinalvariablesTest {

	public static void main(String[] args) {
		
		Finalvariables fv1 = new Finalvariables();
		System.out.printf("fv1.VARS[0] : %s %n", fv1.VARS);
	
		Finalvariables fv2 = new Finalvariables();
		System.out.printf("fv2.VARS[0] : %s %n", fv2.VARS);
		
		Finalvariables fv3 = new Finalvariables();
		System.out.printf("fv3.VARS[0] : %s %n", fv3.VARS);

	}

}
```

```
fv1.VARS[0] : the.finals.TestMember@28d93b30 
fv2.VARS[0] : the.finals.TestMember@28d93b30 
fv3.VARS[0] : the.finals.TestMember@28d93b30 
```

final : 객체 상수

static final : 상수

-&gt; 객체 상수, 상수 뉘앙스 차이는 객체 상수는 첫번째 코드, 상수는 두번째 코드 같은 상황. 교재 253p에 메모리 그림 메모 참고



#### 메서드에서 final 오버라이딩 상속\(확장\) 불가"

```java
package the.finals;

class TestMember{
	// final 메서드 : 오버라이드 금지
	final void testFinalMethod(){
		System.out.println("testFinalMethod()");
	}
}

class TestChild extends TestMember {
	// 
//	void testFinalMethod(){
//		
//	}
}
class Finalvariables {
	// 객체의 상수
	public static final TestMember VARS = new TestMember();
	// getter
	public TestMember getVAR() {
		return VARS;
	}
	
}
public class FinalvariablesTest {

	public static void main(String[] args) {
		
		Finalvariables fv1 = new Finalvariables();
		System.out.printf("fv1.VARS[0] : %s %n", fv1.VARS);
	
		Finalvariables fv2 = new Finalvariables();
		System.out.printf("fv2.VARS[0] : %s %n", fv2.VARS);
		
		Finalvariables fv3 = new Finalvariables();
		System.out.printf("fv3.VARS[0] : %s %n", fv3.VARS);
		
		fv1.VARS.testFinalMethod(); //final 붙였을 때 상속은 됨, 오버라이드 금지
	}

}
```



=&gt; final을 쓰는 경우 3가지 : 변수, 메서드, 클래스

변수에 쓰면 값을 바꿀 수 없는 상수가 됨. 메모리에 객체는 계속 생김, 똑같은 값 계속 생기지 않게 하려면 static도 붙임\(그럼 메모리에 1개만 존재\)

메서드에 쓰면 상속은 되는데\(=자식 객체 만들어서 . 찍었을 때 부모 객체의 final메서드 사용 가능\), 오버라이딩해서 메서드 내용 바꾸는건 불가

클래스에 쓰면 final이 붙은 해당 클래스를 다른 자식 클래스들이 상속 받지 못함









