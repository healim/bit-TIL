## 180320

복습

* [ ] 함수의 형태
  ```
  // static, public이런건 순서 바뀌어도 상관 없고 반환형-메서드명-생성자 순서는 지켜야 함 
  [접근제한][반환형][메서드명](매개변수){
      // 실행문
  }

  return값이 없으면 반환형은 void 
  ```

* [ ] public, static .... 클래스 접근

```
// Scanner 필요

// 파일 입출력에서 입력 처리할 수 있는 부분
// => bufferedWriter
bw.write(msg);
bw.close(); // 실제 파일이 저장되는 시점..

// 파일 읽기
readline
```

---

언제  static 붙이냐?

```java
package the.methods;

class Methodsource {
	/* 외부의 값(매개변수 필요)을 주로 사용하는 메서드 */
	public void add(int pA, int pB){
		System.out.printf("%s+%s=%s\n", pA, pB, (pA + pB));
		
	}
	
	/* 내부의 값-인스턴스 변수값을 주로 사용하는 메서드 */
	String name;
	int age;
	
//	public static void printMember(){
//		// static에서는 name과 age에 접근 불가능함, 왜냐면 name과 age 메모리에 없음
//		// 내부값 쓰는 애들은 static 붙이면 안됨 
//		// 정 쓰고 싶으면 자기 안에서 인스턴스 생성해야 함
//		Methodsource ms = new Methodsource();
//		ms.age = 7; ms.name = "kim"; // 잘못된 사용예
//		
//		
//	}
	
	public void printMember(){
		this.age = 7; this.name = "kim"; 
		// 위에서 static을 지워주면 이 인스턴스 생성된게 전제가 되므로 age, name 접근 가능해짐
		// 근데 이 인스턴스를 지칭할 수 있는 키워드가 없으니까 식별자로 this를 사용해주는 것
		// (this는 이 인스턴스, 생성된 이 인스턴스)
		
		// 내부 애를 주로 사용하려면 static 뺄 수 밖에 없음
	}
}


public class MethodTest {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// 3+4
		Methodsource ms = new Methodsource();
		ms.add(3, 4);
		ms.add(33, 44);
		// 값을 외부에서 받기 때문에 인스턴스 여러개 필요 없음, 하나만 있어도 됨
		// 
		// => 외부데이터 주로 사용하고(class 변수 안 쓰고), 인스턴스 하나만 있어도 되면 static 할 필요 없음
	}
}
```

=&gt; 메모리에 어떻게 생성되서 실행되는지 그림 그려볼 것

#### method test / static 

```java
package the.methods;

class Methodsource {
	/* 외부의 값(매개변수 필요)을 주로 사용하는 메서드 */
	public void add(int pA, int pB){
		System.out.printf("%s+%s=%s\n", pA, pB, (pA + pB));
		
	}
	
	/* 내부의 값-인스턴스 변수값을 주로 사용하는 메서드 */
	String name;
	int age;
	
//	public static void printMember(){
//		// static에서는 name과 age에 접근 불가능함, 왜냐면 name과 age 메모리에 없음
//		// 내부값 쓰는 애들은 static 붙이면 안됨 
//		// 정 쓰고 싶으면 자기 안에서 인스턴스 생성해야 함
//		Methodsource ms = new Methodsource();
//		ms.age = 7; ms.name = "kim"; // 잘못된 사용예
//		
//		
//	}
	
	static String brand = "holly"; // 소속사 
	public void printMember(){
		this.age = 7; this.name = "kim"; 
		// 위에서 static을 지워주면 이 인스턴스 생성된게 전제가 되므로 age, name 접근 가능해짐
		// 근데 이 인스턴스를 지칭할 수 있는 키워드가 없으니까 식별자로 this를 사용해주는 것
		// (this는 이 인스턴스, 생성된 이 인스턴스)
		
		// 내부 애를 주로 사용하려면 static 뺄 수 밖에 없음
		System.out.printf("%s(%s세), %s소속사\n", this.name, this.age, brand);
	}
	
	public void printInfo(){
		System.out.printf("%s(%s세), %s소속사\n", this.name, this.age, brand);
	}
}


public class MethodTest {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// 3+4
		Methodsource ms = new Methodsource();
		ms.add(3, 4);
		ms.add(33, 44);
		// 값을 외부에서 받기 때문에 인스턴스 여러개 필요 없음, 하나만 있어도 됨
		// 
		// => 외부데이터 주로 사용하고(class 변수 안 쓰고), 인스턴스 하나만 있어도 되면 static 할 필요 없음
		
		Methodsource md1 = new Methodsource();
		md1.name = "휴잭맨"; md1.age = 55;
		md1.printMember();
		
		// 배열로 관리할 수 있을까?
		Methodsource[] mss = new Methodsource[3]; // 인스턴스 생성한게 아니라 배열만 3칸 생성한거다. 각 칸에 대한 크기가 methodsource이다.
		/* // 이클립스가 예측하기에 캐스터가 3개 생성된걸로 파악해서 얘 생각에는 문제가 없음, mss 식별자면서 캐스터
		mss[0].name = "휴잭맨"; mss[0].age = 55; //인스턴스 생성 안 하고 이렇게 쓰면 null에다가 . 찍고 name 한 것과 같은 것;; 
		mss[0].printInfo();
		*/
		
		System.out.println("==================");
//		for(Methodsource ele : mss){
//			ele = new Methodsource();
//		} 왜 안되지
		mss[0] = new Methodsource();
		mss[0].name = "휴잭맨"; mss[0].age = 55;
		mss[1] = new Methodsource();
		mss[1].name = "채닝테이텀"; mss[1].age = 37;
		mss[2] = new Methodsource();
		mss[2].name = "로버트 다우 주니어"; mss[2].age = 52;
		
		for(Methodsource ele : mss){
			ele.printInfo();
		}
		
		
	}
}
```



#### method 만들기

```java
package the.methods;

public class NormalMethodTest {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		printIntro("홍길동");
		printIntro("채닝테이텀");
		printIntro("로버트 다우 주니어");

	}
	
	// 기본형 메서드 (void, no parameter)
	// static을 붙여야 위에 main 함수 내에서 실행이 가능해짐
	public static void printIntro(String name){
		System.out.printf("%s님이 입장합니다.\n", name);
		System.out.println("안녕하세요?");
		System.out.println("우리회사를 소개합니다.");
		System.out.println("우리회사 소개를 마칩니다.");
		System.out.println("안녕히가세요!");
		System.out.println("**.....***....**...**");
	}

}
```











