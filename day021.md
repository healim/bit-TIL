## 180329 p363~

어제에 이어서 Collection

#### Linked List

```java
package the.collections;

import java.util.Iterator;
import java.util.LinkedList;

public class QueueEx1 {

    public static void main(String[] args) {
        String[] item = {"소나타", "재규어", "렉스톤"}; // String 배열에 소나타, 재규어, 렉스톤 순으로 들어가서
        LinkedList<String> q = new LinkedList<String>();

        for (String n : item) {
            q.offer(n); // 요소 추가
        }
        System.out.println("q의 크기 : " + q.size());

        String data = "";
        while ((data = q.poll()) != null) { // 들어간 순서대로 소나타 만저 삭제되고, 재규어 삭제되고, 렉스톤 삭제됨
            System.out.println(data + "삭제!");

        }
        System.out.println("q의 크기 : " + q.size());
    }

}
```

실행 결과 예상해보기

```
//
```

#### Map 인터페이스

```java
package the.collections;

import java.util.HashMap;
import java.util.Set;

public class MapEx1 {

    public static void main(String[] args) {
        String[] msg = {"Berlin", "Dortmund", "Frankfurt", "Gelsenkirchen", "Hamburg"};
        HashMap<Integer, String> map = new HashMap<Integer, String>(); // HashMap 생성

        for (int i = 0; i < msg.length; i++) {
            map.put(i, msg[i]); // 맵에 저장
        }

        Set<Integer> keys = map.keySet(); // Map은 인덱스가 없으므로 바로 반복문을 돌 수 없음. 따라서 Set을 함께 사용(키를 알면 값을 가져올 수 있음)
        for (Integer n : keys) {
            System.out.println(map.get(n)); // 맵에서 읽어오기
        }
    }

}
```

...Collection 이해한 바로는 Map, Queue, Linked List.. 이런 것들은 인터페이스\(즉, java만의 것이 아님. 다른 프로그래밍 언어는 각자 고유하게 해당 인터페이스를 구현함\(아마\)\)고, 그 인터페이스를 구현한 각각의 클래스를 사용하여 프로그래밍 한다. 같은 느낌임

컬렉션 개념, 자료구조와 관련있어보임.

=&gt; 아 컬렉션\(자료구조\) 라고 교재에 써있구나. 또 컬렉션을 자바 컬렉션 프레임워크라고 표현하네

---

#### 사용자 정의 타입과 해쉬 셋

```java
package the.collections;

import java.util.HashSet;

import the.objects.Product;

class HashSetClass {
    // 멤버
    String name;
    int age;
    // 생성자
    // => 아아 밑에 hs.add() 해서 넣으려고 하는데 
    // => name, age 입력해야 할 값이 여러개라 불편하니까 생성자를 만들어서 객체 생성하면 되네! (생성자를 괜히 만드는게 아님)
    // => 값 여러개 받아야 하는데 어떻게 값 넣어야 하지.. 고민 했는데 생성자를 써서 초기화해주면 되는구나
    public HashSetClass(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }
    @Override
    public String toString() {
        return String.format("%s(%s년)", this.name, this.age);
    }

    //hashCode()
    // hs.add 될 때마다 자동으로 호출됨, 왜냐면 값 add 하려면 해시코드를 먼저 비교해서 넣을지말지 정해야 하므로
    public int hashCode(){
        System.out.printf("%s의 hashCode() 호출 \r\n", this.name); // 실행 되는지 체크
        // 공식에 의한 해시코드 생성 
        // => the.objects의 Product 함께 볼 것
        return this.name.hashCode()^this.age; //^ XOR 연산자
    }

    //equals()
    public boolean equals(Object obj){ // 오버라이딩 할 때는 매개변수 데이터 타입 같게 해야 한다. 즉 Object 필수로 써야함
        System.out.printf("%s의 equals() 호출 \r\n", this.name); // 실행 되는지 체크
        // 확인    
        return this.hashCode() == obj.hashCode();
    }


public class UserDefinedHashSet {

    public static void main(String[] args) {
        // 사용자 정의 타입과 해쉬 셋
        HashSet<HashSetClass> hcs = new HashSet<>();
        hcs.add(new HashSetClass("짱구",  30));
        hcs.add(new HashSetClass("와타모테",  10));
        hcs.add(new HashSetClass("센과 치히로",  15));
        hcs.add(new HashSetClass("센과 치히로",  15));

        for (HashSetClass str : hcs) {
            System.out.println(str); // toString 출력될 때 해시코드가 모두 다름을 알 수 있음(즉, 센과 치히로 두개 등록됨)
        }

        // 사용자정의 데이터타입 아닌 경우
        HashSet<String> hs = new HashSet<>();
        hs.add("폴란드");
        hs.add("세르비아");
        hs.add("체코");
        hs.add(new String("체코"));
        hs.add(new String("체코"));

        System.out.printf("%s : %s",
                new String("체코").hashCode(),
                new String("체코").hashCode());

        // 반복문으로 출력
        // 일치여부 판단
        // 1. hashCode(); 해시코드의 일치 여부를 판단
        // => "체코", "체코" 오버라이딩해서 체코를 인수로 가져와서 해시코드를 출력하는 것이므로 체코, 체코는 해시코드 같게 나옴
        // 2. equals() 값 확인
        // ==> 사용자 정의 데이터 타입을 만들때는 hashCode()와 equals() 둘다 오버라이딩 해야 한다
        for (String string : hs) {
            System.out.println(string);

        }

    }
}
```

결과값

```
짱구의 hashCode() 호출 
와타모테의 hashCode() 호출 
센과 치히로의 hashCode() 호출 
////////////////////// 여기까지는 새로 생성하니까 바로 되고,
센과 치히로의 hashCode() 호출 // 센과 치히로 같은게 입력 되어서
센과 치히로의 equals() 호출 // hashCode()가 같으니까 equals를 호출하고,
센과 치히로의 hashCode() 호출 // equals 내부에서 return 값을 출력하기 위해 hashCode 두번 호출됨
센과 치히로의 hashCode() 호출 
와타모테(10년)
짱구(30년)
센과 치히로(15년)
///////////// 사용자 정의타입 클래스도 중복 없이 저장됨을 확인할 수 있음
1677600 : 1677600폴란드
세르비아
체코
```

```java
//    /*와 자동으로 코드 생성하니까 HashSetClass 클래스에 맞게 자동으로 hashCode, equals 오버라이딩해주네*/
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + age;
        result = prime * result + ((name == null) ? 0 : name.hashCode()); // name.hashCode()는 String 객체는 같게 나오니까... 
        return result;
        // 아 해시코드 이런 식으로 작동하는거구나
    }
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        HashSetClass other = (HashSetClass) obj;
        if (age != other.age)
            return false;
        if (name == null) {
            if (other.name != null)
                return false;
        } else if (!name.equals(other.name))
            return false;
        return true;
    }
}
```



