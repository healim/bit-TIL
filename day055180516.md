#### 자바 쓰레드

* 쓰레드 활용 예 : 채팅\(싱글 쓰레드는 파일 다운로드 할 때 채팅 못침 ㅋㅋㅋㅋ\), 게임, P2P 파일 다운로드
* 한 메서드 끝나기 전에 다른 메서드 실행 가능해짐
* 멀티 쓰레드 : 한 프로세스 안에 stack 생성, 여러개 메서드 실행 가능해짐
* 멀티 프로세스 : 프로세스\(실행중인 프로그램\)을 여러개 띄울 수 있는 것, 프로세스는 CPU와 대응 \(CPU 2개면 2개의 프로세스까지밖에 실행 못함\)
* 주의 : 멀티 쓰레드는 동시에 처리되는게 아니다. 빠르게 교환되어 동시에 실행되는 것처럼 보이는것임. 

#### No Thread

alpha class

```java
package bit.threads;


public class No_Thread_alpha extends Thread{
    // method


    public void print_alpha() {
        for (int i = 74; i > 64; i--) { // 아스키 코드 알파벳 출력 범위
            System.out.printf("No Thread alpha : %s%n", (char)i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } // 1 second 
        }

    }
}
```

num class

```java
package bit.threads;

public class No_Thread_num {
    // method
    public void print_num() {
        for (int i = 10; i > 0; i--) {
            System.out.printf("No Thread num : %s%n", i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } // 1 second 
        }
    }
}
```

test

```java
package bit.threads;

public class Onethread_test {

    public static void main(String[] args) {
        // 초기
        No_Thread_num nm = new No_Thread_num();
        No_Thread_alpha ap = new No_Thread_alpha();

        nm.print_num();
        ap.print_alpha();


    }

}
```

#### Thread

alpha class

```java
package bit.threads;

// Thread 클래스를 상속
// = 독립적인 스택 영역을 갖는다. 
// -> 시작 메서드 있어야 함 (run 구현(일반적인 클래스 main 역할))
public class Thread_alpha extends Thread{
    // 쓰레드의 시작 메서드
    public void run() {
        print_alpha(); // 시작하자마자 해당 메서드 실행
    }

    // method
    public void print_alpha() {
        for (int i = 74; i > 64; i--) { // 아스키 코드 알파벳 출력 범위
            System.out.printf("No Thread alpha : %s%n", (char)i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } // 1 second 
        }

    }
}
```

num class

```java
package bit.threads;

public class Thread_num extends Thread{

    public void run() {
        print_num();
    }

    // method
    public void print_num() {
        for (int i = 10; i > 0; i--) {
            System.out.printf("No Thread num : %s%n", i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } // 1 second 
        }
    }
}
```

test

```java
package bit.threads;

public class Thread_test {

    public static void main(String[] args) {
        // 초기
        Thread_num nm = new Thread_num();
        Thread_alpha ap = new Thread_alpha();

        // 쓰레드 상속받았더래도 메서드 직접 호출하면 one thread 실행
//        nm.print_num();
//        ap.print_alpha();

        // 멀티쓰레드 실행
        nm.start(); // 쓰레드 생성
        ap.start(); // 가장 먼저 실행되는 메서드 이름은 run
        // 1초 쉬는 동안 바로 옆에 있는거 실행

        // -> 아 그럼 이건 main 스택 하나 있고, nm 스택과 ap 스택이 생성되어 총 3개의 쓰레드를 가지는건가보다. 그럼 메인 함수랑 완전 따로 행동하는건가?

        // 인스턴스 생성하고 run 메서드 호출하면
        // 이 메서드가 알아서 스택 생성하고 내용 실행하게 됨

    }

}
```



쓰레드 왜 lock 필요할까

어차피 쓰레드는 등시에처럼 보이게 하는거지, 동시는 아니라고 들은 것 같은데... 멀티쓰레드 동작 방식 찾아볼 것

멀티 프로세스에는 lock 필요한거 이해 되는데 



```java
package bit.threads;

// 본사 클래스 정의
class HeadOffice {
	// 멤버변수
	static private int stocks = 100; // 지점 객체들이 공유하는 자원, 지점에서 물건 요청시 setter로만 접근 가능하도록 private 설정
	
	// getter, setter
	public static int getStocks() {
		return stocks;
	}

	public static void setStocks(int num) {
		stocks -= num; // 지점에서 요청한 수만큼 본사 재고수 감소
	}
	
	// 본사에 남은 재고수 체크
	public static Boolean available(int requestNum) {
		return (stocks >= requestNum)? true : false; 
	}
}

// 지점 클래스 정의
// 본사 상속, 다중상속을 위해 Thread 인터페이스로 구현
class LocalStroe extends HeadOffice implements Runnable {
	int stocks;
	String name;
	
	// 생성자
	public LocalStroe(String name, int num) {
		super();
		this.name = name; 
		
		// 지점 개설시 본사에 재고가 충분한지 확인 후 개설
		if(HeadOffice.available(num)) {
			this.stocks = num;
			HeadOffice.setStocks(stocks);
			System.out.printf("%s지점이 개점했습니다. (재고수 : %s)%n", this.name, this.stocks);
		} else {
			System.out.println("본사에 재고가 부족합니다. 남은 재고수 : " + HeadOffice.getStocks());
		}
	}
	
	@Override
	public void run() {
		do {
			this.sellProduct();
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		} while (!(this.stocks == 0));
		
	}
	
	// 물건 판매
	public synchronized void sellProduct(){
		int sellNum = (int)(Math.random()*5 + 1); 
		if (this.stocksAvailable(sellNum)) { 
			this.stocks -= sellNum;
			System.out.printf("-- 물건이 판매되었습니다. (%s 판매량 : %s, 현재 재고 : %s)%n", this.name, sellNum, this.stocks);
		} else {
			do {
				this.supplimentStocks();
			} while (this.stocks <= sellNum && HeadOffice.getStocks() >= 1);
		}
	}
	// 본사에 물건 요청
	public synchronized void supplimentStocks(){
		int supplimentNum = (int)(Math.random()*10 + 1); 
		if (HeadOffice.available(supplimentNum)) {
			this.stocks += supplimentNum;
			HeadOffice.setStocks(supplimentNum);
			System.out.printf("본사로부터 재고보충(%s)이 완료되었습니다. (%s 재고수 : %s, 본사 재고수 : %s)%n",
					supplimentNum, this.name, this.stocks, HeadOffice.getStocks());
		} else {
			System.out.printf("본사에 재고가 부족합니다. 가능한 양만 판매하세요. (%s 재고수 : %s, 본사 재고수 : %s)%n",
					this.name, this.stocks, HeadOffice.getStocks());
		}
	}
	
	// 지점에 남은 재고수 체크
	public Boolean stocksAvailable(int requestNum) {
		return (this.stocks >= requestNum)? true : false; 
	}
	
}

public class Thread_review {
	public static void main(String[] args) {
		// 지점 객체 생성
		System.out.println("=======================================");
		LocalStroe seoul = new LocalStroe("서울", 10);
		LocalStroe jeju = new LocalStroe("제주", 20);
		LocalStroe busan = new LocalStroe("부산", 30);
		System.out.println("본사 재고수 : " + HeadOffice.getStocks());
		System.out.println("=======================================");
		
		// 쓰레드 생성
		Thread seoul_store = new Thread(seoul);
		Thread jeju_store = new Thread(jeju);
		Thread busan_store = new Thread(busan);
		
		// 쓰레드 실행
		seoul_store.start();
		jeju_store.start();
		busan_store.start();

		// join
		try {
			seoul_store.join();
			jeju_store.join();
			busan_store.join();
			
			System.out.println("-----------------------본사 물건이 모두 팔렸습니다.");
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}

}

```



